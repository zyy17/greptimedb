searchState.loadedDescShard("promql", 0, "SNAFU context selector for the <code>Error::ColumnNotFound</code> …\nSNAFU context selector for the <code>Error::DataFusionPlanning</code> …\nSNAFU context selector for the <code>Error::Deserialize</code> variant\nSNAFU context selector for the <code>Error::EmptyRange</code> variant\nContains the error value\nSNAFU context selector for the <code>Error::IllegalRange</code> variant\nContains the success value\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return the associated error\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nConsume the selector and return a <code>Result</code> with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmpty source plan that generate record batch with two …\n<code>HistogramFold</code> will fold the conventional (non-native) …\nManipulate the input record batch to make it suitable for …\nTime series manipulator for range function.\n<code>ScalarCalculate</code> is the custom logical plan to calculate …\nAssume the input stream is ordered on the tag columns.\nNormalize the input record batch. Notice that for …\nA special kind of <code>UNION</code>(<code>OR</code> in PromQL) operator, for PromQL …\nExpected output batch size\nInclude time index\nThe columns to compare for equality. TIME INDEX is …\nA optional column for validating staleness\nIndex for field column in the schema of input.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIndex of buffered batches to start inspect next time.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis stream only generate one record batch at the first …\nName of the <code>le</code> column. It’s a special column in …\nIndex for <code>le</code> column in the schema of input.\nColumns need not folding. This indices is based on input …\nNumber of series processed.\nNumber of series processed.\nNumber of series processed.\nNumber of series processed.\nShared the <code>RandomState</code> for the hashing algorithm\nSchema of the output record batch\nSchema of the output record batch\nSchema of the output record batch\n<code>SeriesDivide</code> requires <code>time_index</code> column’s name to …\nSchema that only contains the time index column. This is …\nSchema that only contains the time index column. This is …\nSchema that only contains the time index column. This is …\nEmpty source plan that generate record batch with two …\nBuild a schema that only contains <strong>millisecond</strong> timestamp …\nThis stream only generate one record batch at the first …\nSchema of the output record batch\nSchema of the output record batch\nSchema of the output record batch\nSchema that only contains the time index column. This is …\nSchema that only contains the time index column. This is …\nSchema that only contains the time index column. This is …\n<code>HistogramFold</code> will fold the conventional (non-native) …\nExpected output batch size\nTransform the schema\nGenerate a group of empty MutableVectors from the output …\nEvaluate the field column and return the result\nIndex for field column in the schema of input.\nFind the first <code>+Inf</code> which indicates the end of the bucket …\nFold record batches from input buffer and put to output …\nThe inner most <code>Result</code> is for <code>poll_next()</code>\nName of the <code>le</code> column. It’s a special column in …\nIndex for <code>le</code> column in the schema of input.\nColumns need not folding. This indices is based on input …\nReturn all the PhysicalExpr of tag columns in order.\nCompute result from output buffer\nManipulate the input record batch to make it suitable for …\nA optional column for validating staleness\nNumber of series processed.\nHelper function to apply “take” on record batch.\nNormalize the input record batch. Notice that for …\nNumber of series processed.\nTime series manipulator for range function.\nReturn values:\nNumber of series processed.\n<code>ScalarCalculate</code> is the custom logical plan to calculate …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of this custom plan\ncreate a new <code>ScalarCalculate</code> plan\nwith format <code>(ts_index, field_index)</code>\nCreate a new execution plan from ScalarCalculate\nAssume the input stream is ordered on the tag columns.\nReturn the position to cut buffer. None implies the …\nIndex of buffered batches to start inspect next time.\nNumber of series processed.\n<code>SeriesDivide</code> requires <code>time_index</code> column’s name to …\nThe result is taken\nALL input batches and its hash table\nSimple future state for HashedData\nThe result is not ready\nThe result is ready\nA special kind of <code>UNION</code>(<code>OR</code> in PromQL) operator, for PromQL …\nOutput batch.\nInclude time index\nThe columns to compare for equality. TIME INDEX is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe indices of the columns to be hashed.\nHash table for all input batches. The key is hash value, …\nUtility function to interleave batches. Based on interleave\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nShared the <code>RandomState</code> for the hashing algorithm\nUtility function to take rows from a record batch. Based …\nRemove rows that hash value present in the input record …\nabsent_over_time returns an empty vector if the range …\nThe average value of all points in the specified interval.\nused to count the number of value changes that occur …\nThe count of all values in the specified interval.\nThere are 3 variants of smoothing functions:\nThe <code>funcIdelta</code> in Promql, from …\nThe most recent point value in specified interval.\nThe maximum value of all points in the specified interval.\nThe minimum value of all points in the specified interval.\nthe value 1 for any series in the specified interval.\nused to count the number of times the time series starts …\nthe population standard deviation of the values in the …\nthe population standard variance of the values in the …\nThe sum of all values in the specified interval.\nImplementation of <code>changes</code> in PromQL. Refer to the original …\ncompensation(Kahan) summation algorithm - a technique for …\nImplementation of <code>deriv</code> in PromQL. Refer to the original …\nExtracts an array from a <code>ColumnarValue</code>.\nImplementations of <code>rate</code>, <code>increase</code> and <code>delta</code> functions in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nImplementation of <code>holt_winters</code> in PromQL. Refer to the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nlinear_regression performs a least-square linear …\nImplementation of <code>predict_linear</code> in PromQL. Refer to the …\nCreate a quantile <code>AggregateUDF</code> for PromQL quantile …\nRange length in milliseconds.\nRange length in milliseconds.\nRange length in milliseconds.\nImplementation of <code>reset</code> in PromQL. Refer to the original …\nDuration. The second param of (…\nabsent_over_time returns an empty vector if the range …\nThe average value of all points in the specified interval.\nThe count of all values in the specified interval.\nThe most recent point value in specified interval.\nThe maximum value of all points in the specified interval.\nThe minimum value of all points in the specified interval.\nthe value 1 for any series in the specified interval.\nthe population standard deviation of the values in the …\nthe population standard variance of the values in the …\nThe sum of all values in the specified interval.\nused to count the number of value changes that occur …\nPart of the <code>extrapolatedRate</code> in Promql, from …\nInput parameters:\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstructor. Other public usage should use scalar_udf() …\nRange length in milliseconds.\nRange length in milliseconds.\nRange length in milliseconds.\nRange length in milliseconds.\nThere are 3 variants of smoothing functions:\nRefer to …\nThe <code>funcIdelta</code> in Promql, from …\nDuration. The second param of (…\nRefer to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a quantile <code>AggregateUDF</code> for PromQL quantile …\nused to count the number of times the time series starts …\nCounter for the number of series processed per query.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn compound logical “array” type. Represent serval …\nBuild datatype of wrapped RangeArray on given value type.\nChange the field’s datatype to the type after processed …\nReturns the argument unchanged.\nConstruct RangeArray from given range without checking its …\nCalls <code>U::from(self)</code>.\nReturn the underlying Arrow’s DictionaryArray. Notes the …")